**End-to-End Infrastructure Automation: AWS, Terraform, and Maven**

**Project Objective**
The primary goal of this project was to establish a "One-Click" deployment setup for a cloud environment. I aimed to automate the entire lifecycle—from launching an AWS server to installing Java/Maven and executing a live application—eliminating the need for any manual intervention in the AWS Console.

**Tech Stack**
- Cloud Provider: AWS (EC2)
- Infrastructure as Code (IaC): Terraform
- Language: Java 17 (Amazon Corretto)
- Build Tool: Apache Maven
- Automation: Bash Scripting (via User Data)

**Step-by-Step Implementation**

**1. Initial Setup & Environment Preparation**
Before writing any infrastructure code, I prepared my local control station:

Terraform Installation: Installed Terraform via the official HashiCorp repository to ensure stability.
AWS Authentication: Executed aws configure to securely link my Access Key and Secret Key, granting my local system permission to manage resources on my AWS account.

**2. main.tf file**
I developed a main.tf file that serves as the architectural map for the environment. It includes:

Region: North Virginia (us-east-1).
Instance: A t2.micro instance running Amazon Linux.
Security: Linked the mavenproject key pair for secure SSH access.
Bootstrapping (The Automation Script): I wrote a script that triggers immediately upon server launch to:

Install Java 17 and Apache Maven.
Generate a fresh Maven project structure.
Use the sed command to programmatically update the pom.xml for Java 17 compatibility.
Build and execute the final application.

**sample**
# 1. Cloud Provider Setup with Credentials
provider "aws" {
  region     = "us-east-1"
  access_key = "Your Access-key"  
  secret_key = "Your Secret-key" 

# 2. EC2 Instance Definition
resource "aws_instance" "maven_server" {
  ami           = "ami-02dc6e3e481e2bbc5"
  instance_type = "t2.micro"
  key_name      = "mavenproject"

  tags = {
    Name = "Maven-One-Click-Automation"
  }

  # 3. User Data: Automation Logic
  user_data = <<-EOF
    #!/bin/bash
    sudo yum update -y
    sudo yum install -y java-17-amazon-corretto-devel maven
    
    mkdir -p /opt/my-app
    cd /opt/my-app
    
    mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

cd my-app

    sed -i '/<url>http:\/\/maven.apache.org<\/url>/a \  <properties>\n    <maven.compiler.source>17<\/maven.compiler.source>\n    <maven.compiler.target>17<\/maven.compiler.target>\n  <\/properties>' pom.xml

    mvn clean package > /var/log/maven_build.log
    java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App > /var/log/app_output.log
  EOF
}

**3. Execution Workflow**
The project was deployed using the standard Terraform lifecycle:

Bash
terraform init          # Downloads the required AWS plugins
terraform validate      # Verifies the code for syntax errors
terraform plan          # Previews the exact resources to be built
terraform apply -auto-approve  # Launches the server and starts the automation

**Challenges & Troubleshooting**
- During development, I faced several real-world hurdles and successfully resolved them:
- Credential Recognition: Terraform initially failed to recognize my AWS account. I resolved this by re-running aws configure and verifying my IAM keys.
- Script Encoding Issues: The automation script failed to execute due to encoding errors. I fixed this by using the <<-EOF (Heredoc) format, making the script clean and readable for the server.
- SSH Connection Timeout: I was unable to log into the server initially. I identified that Port 22 was closed by default and manually updated the AWS Security Group settings to allow SSH access.

**Verifying the Results**
After deployment, I logged into the instance via SSH to audit the automated logs:

Build Success: Running cat /var/log/maven_build.log showed a "BUILD SUCCESS" status.
App Output: Running cat /var/log/app_output.log displayed the "Hello World!" message, confirming the automation worked perfectly.

**Clean Up**
To follow cost-management best practices, I decommission the infrastructure after testing:

Bash
terraform destroy -auto-approve  # Safely deletes all resources
